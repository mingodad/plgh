/*
Grammar originally from https://sourceforge.net/projects/libparser/
	files test/grammar/parser_c_preproc.bnf and test/grammar/scanner_c_preproc.bnf
Manually converted to be viewd  by https://www.bottlecaps.de/rr/ui (correctnes is not the priority now)
*/

PREPROCESSOR ::= CODE CONTROL_LINE PREPROCESSOR
		| CODE


// accept anything that is not a control line or a directive end
CODE_WITHOUT_DIRECTEND ::= CODE_WITHOUT_DIRECTEND CODE_TOKEN_WITHOUT_DIRECTEND
		| /* empty */


// accept anything that is not a control line
CODE ::= CODE CODE_TOKEN
		| /* empty */


CODE_TOKEN ::= CODE_TOKEN_WITHOUT_DIRECTEND
		| DIRECTIVE_END


CODE_TOKEN_WITHOUT_DIRECTEND ::= DEFINED
		| IDENTIFIER
		| MACRO
		| CONSTANT
		| FILENAME_SYSTEM
		| STRING_LITERAL
		| COMMA
		| P_OPEN
		| P_CLOSE
		| RIGHT_OP
		| LEFT_OP
		| AND_OP
		| OR_OP
		| LE_OP
		| GE_OP
		| EQ_OP
		| NE_OP
		| DOT
		| AND
		| NOT
		| NEG
		| LESS_SIG
		| PLUS_SIG
		| MUL
		| DIV
		| MOD
		| LESS
		| GREATER
		| XOR
		| OR
		| TEXT


CONTROL_LINE ::= DEFINE_LINE
		| UNDEF_LINE
		| INCLUDE_LINE
		| CONDITIONAL
		| LINE_LINE
		| ERROR_LINE
		| WARNING_LINE
		| PRAGMA_LINE


DEFINE_LINE ::= DEFINE IDENTIFIER CODE_WITHOUT_DIRECTEND DIRECTIVE_END
		| DEFINE MACRO IDENTIFIER_LIST P_CLOSE CODE_WITHOUT_DIRECTEND DIRECTIVE_END
		| DEFINE MACRO P_CLOSE CODE_WITHOUT_DIRECTEND DIRECTIVE_END


UNDEF_LINE ::= UNDEF IDENTIFIER DIRECTIVE_END

INCLUDE_LINE ::= INCLUDE FILENAME_SYSTEM DIRECTIVE_END
		| INCLUDE STRING_LITERAL DIRECTIVE_END
		| INCLUDE IDENTIFIER DIRECTIVE_END


LINE_LINE ::= LINE CONSTANT STRING_LITERAL DIRECTIVE_END
		| LINE CONSTANT DIRECTIVE_END


ERROR_LINE ::= ERROR STRING_LITERAL DIRECTIVE_END

WARNING_LINE ::= WARNING STRING_LITERAL DIRECTIVE_END

PRAGMA_LINE ::= PRAGMA STRING_LITERAL DIRECTIVE_END

CONDITIONAL ::= IF_LINE PREPROCESSOR ELIF_PARTS

IF_LINE ::= IF CODE_WITHOUT_DIRECTEND DIRECTIVE_END
		| IFDEF IDENTIFIER DIRECTIVE_END
		| IFNDEF IDENTIFIER DIRECTIVE_END


ENDIF_LINE ::= ENDIF DIRECTIVE_END

ELIF_PARTS ::= ELIF_LINE PREPROCESSOR ELIF_PARTS
		| ELSE_PART


ELSE_PART ::= ELSE_LINE PREPROCESSOR ENDIF_LINE
		| ENDIF_LINE


ELIF_LINE ::= ELIF CODE_WITHOUT_DIRECTEND DIRECTIVE_END

ELSE_LINE ::= ELSE DIRECTIVE_END

IDENTIFIER_LIST ::= IDENTIFIER COMMA IDENTIFIER_LIST
		| IDENTIFIER

/* scanner */

/*ignore*/ COMMENT ::= ("/*"([^\*]|("*"+[^\*/]))*"*"+"/")|("//"[^\n]*)

/*ignore*/ DIRECTIVE_CONTINUE ::= "\\\n"

DIRECTIVE_END ::= "\n"

DEFINE ::= "#define"
DEFINED ::= "defined"
UNDEF ::= "#undef"
INCLUDE ::= "#include"
IF ::= "#if"
IFDEF ::= "#ifdef"
IFNDEF ::= "#ifndef"
ELSE ::= "#else"
ELIF ::= "#elif"
ENDIF ::= "#endif"

LINE ::= "#line"
ERROR ::= "#error"
WARNING ::= "#warning"
PRAGMA ::= "#pragma"

IDENTIFIER ::= [_a-zA-Z][_a-zA-Z0-9]*

/*
 * MACRO is a workaround becouse in the expression
 * #define a (b) c
 * if there is a whitespace between a and (b), it is a ordinary define
 * if there is no whitespace, then it's a macro,
 * as our lexer ignores whitespaces, we define the token MACRO
 * that is an identifier with a '(' in the end
*/
MACRO ::= [_a-zA-Z][_a-zA-Z0-9]*

CONSTANT ::= "0"[xX]([0-9a-fA-F])+[uUlL]?
CONSTANT ::= [0-9]+[uUlL]?
CONSTANT ::= "'"([^\']|"\'")+"'"

CONSTANT ::= [0-9]+[eE][\+-]?[0-9]+[fFlL]?
CONSTANT ::= [0-9]+'.'[0-9]*([eE][\+-]?)?[0-9]+[fFlL]?
CONSTANT ::= [0-9]*'.'[0-9]+([eE][\+-]?)?[0-9]+[fFlL]?

FILENAME_SYSTEM ::= "<" [^>]* ">"
STRING_LITERAL ::= '"' ([^\"]|'\"')* '"'

ELLIPSIS ::= "..."
RIGHT_ASSIGN ::= ">>="
LEFT_ASSIGN ::= "<<="
ADD_ASSIGN ::= "+="
SUB_ASSIGN ::= "-="
MUL_ASSIGN ::= "*="
DIV_ASSIGN ::= "/="
MOD_ASSIGN ::= "%="
AND_ASSIGN ::= "&="
XOR_ASSIGN ::= "^="
OR_ASSIGN ::= "|="

RIGHT_OP ::= ">>"
LEFT_OP ::= "<<"
INC_OP ::= "++"
DEC_OP ::= "--"
PTR_OP ::= "->"
AND_OP ::= "&&"
OR_OP ::= "||"
LE_OP ::= "<="
GE_OP ::= ">="
EQ_OP ::= "=="
NE_OP ::= "!="

INST_END ::= ";"
BEGIN ::= "{"
END ::= "}"
COMMA ::= ","
COLUMN ::= ":"
EQ ::= "="
P_OPEN ::= "("
P_CLOSE ::= ")"
B_OPEN ::= "["
B_CLOSE ::= "]"
DOT ::= "."
AND ::= "&"
NOT ::= "!"
NEG ::= "~"
LESS_SIG ::= "-"
PLUS_SIG ::= "+"
MUL ::= "*"
DIV ::= "/"
MOD ::= "%"
LESS ::= "<"
GREATER ::= ">"
XOR ::= "^"
OR ::= "|"
QUESTION ::= "?"

/*ignore*/ WHITESPCE ::= "[ \t\f\r]+"

// the text will be generated by PreprocessorScanner.
// define it's regex to be never used here
TEXT ::= " "
